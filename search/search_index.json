{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>The django-image-uploader-widget is a widget to django, specially django-admin to handle better image uploads with a modern and beautiful user interface.</p>"},{"location":"#features","title":"Features","text":"<p>Some of the features of this widget is:</p> <ul> <li>Beautiful user interface.</li> <li>Handle drop files from your file manager.</li> <li>Handle select file by click in the widget or by droping the image (previous item).</li> <li>Inline editor provided to work with multiple images.</li> <li>Modal to view the full image (The images are adjusted as cover in the preview box, then, in some cases, that is very useful).</li> </ul> <p></p> <p></p> <p></p>"},{"location":"#getting-started_1","title":"Getting Started","text":"<p>To get started, install this plugin with the pip package manager:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>then, go to the <code>settings.py</code> file and add the <code>image_uploader_widget</code> to the installed apps:</p> <pre><code>INSTALLED_APPS = [\n    'my_app.apps.MyAppConfig',\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'django.forms',\n    'image_uploader_widget',\n]\n</code></pre>"},{"location":"#using","title":"Using","text":"<p>Now, you must be able to use the widget in your forms:</p> <pre><code># forms.py\nfrom django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ExampleForm(forms.ModelForm):\n    class Meta:\n        widgets = {\n            'image': ImageUploaderWidget(),\n        }\n        fields = '__all__'\n</code></pre>"},{"location":"#code-example","title":"Code Example","text":"<p>For code direct examples, check the <code>image_uploader_widget_demo</code> folder in the Github repository.</p>"},{"location":"array_field/prevent-raw-change/","title":"Prevent Raw Images Path Change","text":"<p>Like various other <code>multiple</code> instances or values support, we have an tiny problem at this component, for now: when we save a form with some \"unchanged\" values, i.e., with the current file path string instead of an uploaded file, this string is used to store in the database. Is planed, in the future, change this to use the original array values to confirm the sended values. But, for this first version, this is a issue that is not resolved.</p> <p>Example of how this works: navigate to widget change, and find for the hidden input with <code>-RAW</code> name. Change the value to another and saves. The wrong value is correctly saved.</p> <p></p>"},{"location":"array_field/prevent-raw-change/#how-to-prevent-this-behaviour","title":"How to prevent this behaviour?","text":"<p>One of the way to prevent this behaviour is create a custom <code>ModelForm</code> and raises a <code>ValidationError</code> for string values that is not present on the original value. See a example:</p> <pre><code>from django import forms\nfrom django.core.exceptions import ValidationError\n\n\nclass TestWithArrayFieldForm(forms.ModelForm):\n    old_values = []\n\n    def map_is_valid_images(self, value):\n        if not isinstance(value, str):\n            return False\n        return value not in self.old_values\n\n    def clean(self):\n        data = super().clean()\n\n        self.old_values = []\n        if self.instance is not None:\n            self.old_values = self.instance.images\n\n        has_changed = any(list(map(self.map_is_valid_images, data.get('images'))))\n        if has_changed:\n            raise ValidationError('One of the non-changed value is corrupted.')\n\n        return data\n\n    class Meta:\n        model = TestWithArrayField\n        fields = \"__all__\"\n</code></pre>"},{"location":"array_field/tutorial/","title":"Use ImageListField to store Multiple Images","text":"<p>Version Information</p> <p>Introduced at the 0.5.0 version.</p> <p>Database Information</p> <p>Supported only on PostgreSQL Database's.</p> <p>The <code>widget</code> only supports ImageField and this is a limitation to upload only one image per widget. The <code>inline admin</code> support multiple images upload but it is only supported by the <code>django.contrib.admin</code> pages.</p> <p>Some comments, like the Discussion #97, Issue #146 and Issue #110 make some feature requests and the Issue #146 takes one proposition: uses the <code>ArrayField</code>. The <code>ArrayField</code> is a <code>PostgreSQL</code> specific field and support for storing multiple values into one field.</p>"},{"location":"array_field/tutorial/#experimental-for-now","title":"Experimental for Now?","text":"<p>Currently, we have added support, addaptating the <code>inline admin</code> feature to work widget-like and add support for the <code>ArrayField</code> to store images using the <code>storage</code> and save it path to an <code>ArrayField</code>. This is, really, a little experimental for now, and can contains some bugs. If your found one: open a Issue reporting.</p> <p>Attention Point</p> <p>See the attention point on the Prevent Raw Images Path Change page.</p>"},{"location":"array_field/tutorial/#usage","title":"Usage","text":"<p>Instead of <code>widget</code> or <code>inline admin</code> that we only set the <code>widget</code> and <code>inline admin</code> for the created model, in this part, we need to customize the model.</p> <pre><code>from django.db import models\nfrom image_uploader_widget.postgres import ImageListField\n\nclass TestWithArrayField(models.Model):\n    images = ImageListField(blank=True, null=True, upload_to=\"admin_test\")\n\n    class Meta:\n        verbose_name = \"Test With Array Field\"\n</code></pre> <p>This is really simple and is not needed to create more customizations. The widget and form is automatic created for the custom multiple images widget.</p>"},{"location":"customization/colors/","title":"Colors","text":"<p>To customize the image uploader widget colors you can use your own css file to override the css variables defined by the <code>image-uploader-inline.css</code> and <code>image-uploader-widget.css</code>. See an example, taken from another personal private project:</p> <pre><code>body {\n    --iuw-background: #{$dashdark} !important;\n    --iuw-border-color: #{$dashborder} !important;\n    --iuw-color: #{$dashgray} !important;\n    --iuw-placeholder-text-color: #{$dashgray} !important;\n    --iuw-dropzone-background: #{$dashlight} !important;\n    --iuw-image-preview-border: #{$dashborder} !important;\n    --iuw-image-preview-shadow: rgba(0, 0, 0, 0.3);\n    --iuw-add-image-background: #{$dashlight} !important;\n    --iuw-add-image-color: #{$dashgray} !important;\n}\n</code></pre> <p>Observation: To see better the variables name, check the css file at the GitHub repository: here or here.</p>"},{"location":"customization/text-and-icons/","title":"Text And Icons","text":"<p>To customize the image uploader widget or inline you can set some variables (this feature is based on the issue #77). In this page we talk about how to, easy, change the texts and icons on that lib.</p>"},{"location":"customization/text-and-icons/#widget","title":"Widget","text":"<p>For the widget, to customize the icon and the text we need to set some variables in the <code>ImageUploaderWidget</code> constructor, like it:</p> <pre><code># ...\nclass TestCustomForm(forms.ModelForm):\n    class Meta:\n        model = CustomWidget\n        widgets = {\n            'image': ImageUploaderWidget(\n                drop_icon=\"&lt;svg ...&gt;&lt;/svg&gt;\",\n                drop_text=\"Custom Drop Text\",\n                empty_icon=\"&lt;svg ...&gt;&lt;/svg&gt;\",\n                empty_text=\"Custom Empty Marker Text\",\n            ),\n        }\n        fields = '__all__'\n</code></pre> <p>In this example, we set all four properties (<code>drop_icon</code>, <code>drop_text</code>, <code>empty_icon</code> and <code>empty_text</code>) for the widget. In the icons is possible to use the <code>django.shortcuts.render</code> (REF) to renderize the icon from an HTML template.</p> <p>Another way for customize it is create an new widget class based on that and use it for your forms:</p> <pre><code>class MyCustomWidget(ImageUploaderWidget):\n    drop_text = \"\"\n    empty_text = \"\"\n\n    def get_empty_icon(self):\n        return render(...)\n\n    def get_drop_icon(self):\n        return render(...)\n\nclass TestCustomForm(forms.ModelForm):\n    class Meta:\n        model = CustomWidget\n        widgets = {\n            'image': MyCustomWidget()\n        }\n        fields = '__all__'\n</code></pre>"},{"location":"customization/text-and-icons/#inline-editor","title":"Inline Editor","text":"<p>To customize the text and the icons of the inline editor is a little bit faster too. We can set some variables on the <code>InlineAdmin</code> of your model, like this:</p> <pre><code>class CustomInlineEditor(ImageUploaderInline):\n    model = models.CustomInlineItem\n    add_image_text = \"add_image_text\"\n    drop_text = \"drop_text\"\n    empty_text = \"empty_text\"\n\n    def get_empty_icon(self):\n        return render(...)\n\n    def get_add_icon(self):\n        return render(...)\n\n    def get_drop_icon(self):\n        return render(...)\n\n@admin.register(models.CustomInline)\nclass CustomInlineAdmin(admin.ModelAdmin):\n    inlines = [CustomInlineEditor]\n</code></pre>"},{"location":"development/tests/","title":"Tests","text":"<p>To maintain the integrity of the features of this project we have written some integration tests to grant that main features of the widget and inline admin is really good.</p>"},{"location":"development/tests/#functional-tests","title":"Functional Tests","text":"<p>In the decision to write the tests we opted for writing only integration tests using the selenium. And the reason for it is: our project uses much more JavaScript for web browser than Python code for back-end and runs in high coupling with the django-admin. In this context, unit tests are expendable.</p>"},{"location":"development/tests/#some-unit-tests","title":"Some unit tests","text":"<p>In the note block above i talked about not using unit test cases, and in the decisions of the issue #77 we decided to add one unit test for the translation of the widget (tests/widget/functional/tests_functional_widget_custom.py).</p>"},{"location":"development/tests/#ui-regression-tests","title":"UI Regression Tests","text":"<p>In some versions of django, specially in some django 4.x versions, the style of the widget was broken. The behaviour is described in the issue #96. Due this behaviour, we decided to implements some UI Regression Tests and make some fixes to solve this problem.</p>"},{"location":"development/tests/#some-tests-decisions-and-workarounds","title":"Some Tests Decisions and Workarounds","text":"<p>When testing with selenium is not possible to hack the file picker to choose some file. And in this project, in some moments we use an temporary file input for choosing files without compromise the current choosed file. Based on those context, to test correctly fires to onClick event of the temporary file input, we added an JavaScript to add an onClick event showing an alert and test for this alert into the screen.</p>"},{"location":"development/tests/#an-test-project","title":"An test project","text":"<p>For easy testing, we used the demo project <code>image_uploader_widget_demo</code> for writing base models for test add the tests for this project instead of the main component project.</p>"},{"location":"development/tests/#test-cases","title":"Test Cases","text":"<p>You can read (or contribute, if you want to improve this project) the test cases inside the <code>/tests</code> path inside the github repository here.</p>"},{"location":"development/architecture-decision-records/0000-why-jquery/","title":"ADR 0000: Why jQuery?","text":"November 2023. Eduardo Oliveira"},{"location":"development/architecture-decision-records/0000-why-jquery/#context","title":"Context","text":"<p>Some of the <code>django-admin</code> scripts uses jQuery and we need to decide if we will use jQuery or not.</p>"},{"location":"development/architecture-decision-records/0000-why-jquery/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>We need to maintain retrocompatibility with <code>Django 3.2</code> and new versions of <code>Django 4.x</code>.</li> <li>Our code don't have any dependencies to jQuery.</li> </ul>"},{"location":"development/architecture-decision-records/0000-why-jquery/#decision","title":"Decision","text":"<p>At the <code>Django 3.2</code> and <code>Django 4.0</code> version, the <code>inlines.js</code> script (a script to control the inlines form inside the <code>django-admin</code>) dispatch <code>formset:added</code> event as jQuery <code>trigger()</code> event. This event can't be catched using native event handlers [inlines.js#L91].</p> <p>At <code>Django 4.1.x</code> version, this event dispatch was transformed to use native browser <code>CustomEvent</code> [inlines.js#L91]. The other side way is valid: if we dispatched the event using native <code>CustomEvent</code> can be catched by the jQuery <code>on()</code> method. Then, to maintain compatibility with <code>Django 4.0.x</code> and <code>Django 3.2.x</code>, we decided to use jQuery at this project with one restriction:</p> <ul> <li>jQuery is used, and your use is alowed only in this case, to start the widget inside inlines formset.</li> </ul>"},{"location":"development/architecture-decision-records/0001-why-functional-tests/","title":"ADR 0001: Why functional tests?","text":"November 2023. Eduardo Oliveira"},{"location":"development/architecture-decision-records/0001-why-functional-tests/#context","title":"Context","text":"<p>To write tests to maintain the confiability of the project, we decided to write some tests. </p>"},{"location":"development/architecture-decision-records/0001-why-functional-tests/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>We need to write comprehensive tests.</li> <li>We need robust and well-tested tools.</li> <li>The less complexity the tests add to the codebase, better.</li> </ul>"},{"location":"development/architecture-decision-records/0001-why-functional-tests/#considered-options","title":"Considered Options","text":"<ul> <li>Write unit tests for django project and unit/integration tests for javascript using two separate tools (one for each stack).</li> <li>Write functional tests for django using selenium (currently playwright).</li> </ul>"},{"location":"development/architecture-decision-records/0001-why-functional-tests/#decision","title":"Decision","text":"<p>To write tests with less possible complexity, we decided to write functional tests with selenium (currently playwright). The <code>django.contrib.staticfiles.testing.StaticLiveServerTestCase</code> is a goog approach to run the application with selenium or any other in-browser testing tool (currently playwright). We considered the possibility of use two separated test-cases, one for <code>django</code> and one for <code>javascript</code>, will increase the complexity. Based on this, the majority of our tests are functional (or e2e?) tests.</p>"},{"location":"development/architecture-decision-records/0002-why-ui-regression-tests/","title":"ADR 0002: Why UI regression tests?","text":"November 2023. Eduardo Oliveira"},{"location":"development/architecture-decision-records/0002-why-ui-regression-tests/#context","title":"Context","text":"<p>Some Django versions have significant visual differences. One example of this was documented on the issue #96.</p>"},{"location":"development/architecture-decision-records/0002-why-ui-regression-tests/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>We need to maintain retrocompatibility with various versions of Django.</li> <li>We need to grant the behaviour and the visual of the widget and inline in various versions of Django.</li> </ul>"},{"location":"development/architecture-decision-records/0002-why-ui-regression-tests/#decision","title":"Decision","text":"<p>To grant the visual of the widget and the inlines in various versions of Django, we decided to implements UI regression tests using the selenium (currently playwright) to take screenshots of the root element of the widget or inline and compare it with other saved screenshots.</p> <p>Some problems and solutions that are writed for this project was found at my blogpost in brazillian portuguese.</p>"},{"location":"development/architecture-decision-records/0003-why-playwright/","title":"ADR 0003: Why Playwright?","text":"December 2023. Eduardo Oliveira"},{"location":"development/architecture-decision-records/0003-why-playwright/#context","title":"Context","text":"<p>The selenium is very slow to run our tests and we decided to switch from the selenium to another e2e testing framework.</p>"},{"location":"development/architecture-decision-records/0003-why-playwright/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>We need to switch to another e2e testing framework to test our widget. See the ADR 0001 and the ADR 0002 to understand the motivation for the e2e testing framework.</li> <li>We need to get a testing framework that we can rewrite the tests fast.</li> <li>we need to get support to take screenshot of elements for the ADR 0002.</li> </ul>"},{"location":"development/architecture-decision-records/0003-why-playwright/#considered-options","title":"Considered Options","text":"<p>We considered only the two options bellow:</p> <ul> <li>Playwright: enables reliable end-to-end testing for modern web apps.</li> <li>Selenium: automates browsers.</li> </ul>"},{"location":"development/architecture-decision-records/0003-why-playwright/#decision","title":"Decision","text":"<p>The playwright API is a little bit more semantic than the selenium and is faster. For this reason, we decided to use playwright and rewrite our integration and ui-regression tests with playwright.</p>"},{"location":"development/architecture-decision-records/0004-why-mkdocs/","title":"ADR 0004: Why Mkdocs instead of docusaurus?","text":"March 2024. Eduardo Oliveira"},{"location":"development/architecture-decision-records/0004-why-mkdocs/#context","title":"Context","text":"<p>The documentation of the <code>django-image-uploader-widget</code> is full based on a docusaurus documentation generation. This was decided, by me, for some reasons. The most important reason is: i have a large expertise working with JavaScript and i known the docusaurus usage and, then, i created the documentation with small effort.</p> <p>Based on the first paragraph, we need to talk about one point: the docusaurus insert much complexity for the documentation with some <code>React</code> code and various node configurations, only for the documentation.</p>"},{"location":"development/architecture-decision-records/0004-why-mkdocs/#decision-drivers","title":"Decision Drivers","text":"<ul> <li>We need to simplify the tolling for this open-source package.</li> <li>Docusaurus insert much complexity and configuration files.</li> <li>Docusaurus is not known by most part of the python and django community.</li> </ul>"},{"location":"development/architecture-decision-records/0004-why-mkdocs/#considered-options","title":"Considered Options","text":"<p>We considered the two options bellow:</p> <ul> <li>Maintain the <code>docusaurus</code> documentation and continue using it.</li> <li>Change to the <code>mkdocs</code> documentation.</li> </ul>"},{"location":"development/architecture-decision-records/0004-why-mkdocs/#decision","title":"Decision","text":"<p>We decided to change the documentation to the <code>mkdocs</code> based on some points:</p> <ul> <li>Move all the possible tolling to the python community tools.</li> <li>The <code>FastAPI</code> documentation, writen in <code>mkdocs</code> is a very important success case for <code>mkdocs</code>.</li> <li>We have some tooling, like mkautodoc to better support things like the <code>API Reference</code> full integrated from code to documentation.</li> </ul>"},{"location":"inline_admin/accept/","title":"Accept Input Attribute","text":"<p>Like as the Widget <code>accept</code> attribute, see reference here, we have an way to customize the accept of the <code>ImageUploaderInline</code>. To customize it, use the <code>accept</code> property inside an class that inherits from <code>ImageUploaderInline</code>, like:</p> <pre><code>from image_uploader_widget.admin import ImageUploaderInline\nfrom . import models\n\nclass InlineEditor(ImageUploaderInline):\n    model = models.InlineItem\n    accept = \"image/jpeg\"\n</code></pre>"},{"location":"inline_admin/ordered/","title":"Ordered Images Admin","text":"<p>Version Information</p> <p>Introduced at the 0.4.1 version.</p> <p>The first thing needed to understand the ordered version of the <code>ImageUploaderInline</code> is read the inline tutorial. This page has a documentation of how to extend the <code>ImageUploaderInline</code> with order field to allow to reorder, by clicking and dragging, the images inside the inline.</p> <p></p>"},{"location":"inline_admin/ordered/#adding-order-field-to-model","title":"Adding Order Field to Model","text":"<p>Add a <code>PositiveIntegerField</code> to the model to store the order of the images inside the admin.</p> <pre><code># ecommerce/models.py\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        verbose_name = 'Product'\n        verbose_name_plural = 'Products'\n\nclass ProductImage(models.Model):\n    product = models.ForeignKey(\n        Product,\n        related_name=\"images\",\n        on_delete=models.CASCADE\n    )\n    image = models.ImageField(\"image\")\n    order = models.PositiveIntegerField('Order', default=1)\n\n    def __str__(self):\n        return str(self.image)\n\n    class Meta:\n        verbose_name = 'Product Image'\n        verbose_name_plural = 'Product Images'\n</code></pre>"},{"location":"inline_admin/ordered/#change-inline-to-orderedimageuploaderinline","title":"Change inline to OrderedImageUploaderInline","text":"<p>Inside the <code>admin.py</code>, change the inline from <code>ImageUploaderInline</code> to <code>OrderedImageUploaderInline</code> and setup some configs:</p> <pre><code># ecommerce/admin.py\nfrom django.contrib import admin\nfrom ecommerce.models import Product, ProductImage\nfrom image_uploader_widget.admin import ImageUploaderInline\n\nclass ProductImageAdmin(OrderedImageUploaderInline):\n    model = ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    inlines = [ProductImageAdmin]\n</code></pre>"},{"location":"inline_admin/ordered/#attributes","title":"Attributes","text":"Attribute Type Default Value Description order_field <code>str</code> <code>\"order\"</code> The name of field that represents the order of images. template <code>str</code> <code>\"admin/edit_inline/ordered_image_uploader.html\"</code> The template path to render the widget. <p>All the attributes from the <code>ImageUploaderInline</code> are present too. For example, is possible to change the name of the used <code>order_field</code> by adding it's attribute to the <code>OrderedImageUploaderInline</code>:</p> <pre><code>from image_uploader_widget.admin import ImageUploaderInline\n\nclass MyInlineAdminAdmin(OrderedImageUploaderInline):\n    model = MyModel\n    order_field = \"my_custom_field\"\n</code></pre>"},{"location":"inline_admin/tutorial/","title":"Tutorial","text":"<p>First, we need of some context: the image uploader inline is an inline admin editor (like the StackedInline or the TabularInline of the original django). This inline editor is created to make an multiple images manager widget using an model with an image field.</p>"},{"location":"inline_admin/tutorial/#creating-a-django-project","title":"Creating a django project","text":"<p>First, create a project folder. Here we call it as <code>my-ecommerce</code>:</p> <pre><code>mkdir my-ecommerce\ncd my-ecommerce\n</code></pre> <p>And, now, create a django project in this folder:</p> <pre><code>django-admin startproject core .\n</code></pre> <p>And, then, we have the folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - manage.py\n</code></pre> <p>Create our django application by running the command:</p> <pre><code>python manage.py startapp ecommerce\n</code></pre> <p>And, now, we have a new, and more complex, folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - ecommerce\n    | - migrations\n      | - __init__.py\n    | - admin.py\n    | - apps.py\n    | - __init__.py\n    | - models.py\n    | - tests.py\n    | - views.py\n  | - manage.py\n</code></pre>"},{"location":"inline_admin/tutorial/#installing-the-widget","title":"Installing the widget","text":"<p>To install the widget, is possible to use the same instructions of the Getting started, and the first step is to install the package with pip:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>then, add it to the <code>INSTALLED_APPS</code> on the <code>settings.py</code>, in the case of this example: <code>core/settings.py</code> file. To understand better the Applications, see the django documentation: Applications.</p> <pre><code># core/settings.py\n# ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n]\n\n# ...\n</code></pre>"},{"location":"inline_admin/tutorial/#warning","title":"Warning","text":"<p>Observation: note that the application name to be added on the <code>INSTALLED_APPS</code> are not equals to the pip package name / install name.</p>"},{"location":"inline_admin/tutorial/#using-the-inline-editor","title":"Using the inline editor","text":"<p>This inline editor is created to be used directly with the django-admin interface. To show how to use it, go to create two basic models inside the <code>ecommerce</code> app (Add your app, <code>ecommerce</code> in my case, at <code>INSTALLED_APPS</code> is recommended):</p> <pre><code># ecommerce/models.py\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        verbose_name = 'Product'\n        verbose_name_plural = 'Products'\n\nclass ProductImage(models.Model):\n    product = models.ForeignKey(\n        Product,\n        related_name=\"images\",\n        on_delete=models.CASCADE\n    )\n    image = models.ImageField(\"image\")\n\n    def __str__(self):\n        return str(self.image)\n\n    class Meta:\n        verbose_name = 'Product Image'\n        verbose_name_plural = 'Product Images'\n</code></pre> <p>Now, inside our admin, we can create an primary ModelAdmin for the product:</p> <pre><code># ecommerce/admin.py\nfrom django.contrib import admin\nfrom ecommerce.models import Product, ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    pass\n</code></pre> <p>And, now, we can define our inline widget:</p> <pre><code># ecommerce/admin.py\nfrom django.contrib import admin\nfrom ecommerce.models import Product, ProductImage\nfrom image_uploader_widget.admin import ImageUploaderInline\n\nclass ProductImageAdmin(ImageUploaderInline):\n    model = ProductImage\n\n@admin.register(Product)\nclass ProductAdmin(admin.ModelAdmin):\n    inlines = [ProductImageAdmin]\n</code></pre> <p>And we got the inline editor working as well:</p> <p></p>"},{"location":"widget/accept/","title":"Accept Input Attribute","text":"<p>When working with HTML <code>&lt;input /&gt;</code> element, we have an <code>accept=\"\"</code> attribute that works defining the visible file types into the file picker dialog. An better, and complete, description of this attribute can be found at MDN.</p> <p>To define this attribute, with the <code>ImageUploaderWidget</code>, we can set the <code>attrs</code> property when instantiate the <code>ImageUploaderWidget</code>, like:</p> <pre><code>from django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import CustomWidget\n\nclass TestForm(forms.ModelForm):\n    class Meta:\n        widgets = {\n            'image': ImageUploaderWidget(attrs={ 'accept': 'image/png' }),\n        }\n        fields = '__all__'\n</code></pre>"},{"location":"widget/multiple-instances-of-same-form/","title":"Multiple Instances of Same Form","text":"<p>On the issue #112, @tlcaputi asked about using the <code>django-image-uploader-widget</code> with several forms. The answer for this issue, motivated this documentation article.</p> <p>The basic idea for this article is: we have an <code>view</code> with multiples instances of the same <code>ModelForm</code> with one (or more) <code>django-image-uploader-widget</code>. For example, we have a <code>Event</code> model, a <code>EventEditForm</code> model form, a <code>page</code> view and a <code>page.html</code> template:</p> <pre><code># models.py\nfrom django.db import models\n\nclass Event(models.Model):\n    event_title = models.CharField(max_length=200)\n    headshot = models.ImageField(upload_to='profile_pictures/', default='profile_pictures/default.jpg')\n</code></pre> <pre><code># forms.py\nfrom django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import Event\n\nclass EventEditForm(forms.ModelForm):\n    class Meta:\n        model = Event\n        widgets = {\n            'headshot': ImageUploaderWidget(),\n        }\n        fields = [\n            'event_title',\n            'headshot'\n        ]\n</code></pre> <pre><code># views.py\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom .models import Event\nfrom .forms import EventEditForm\n\ndef page(request):\n    if request.method == \"GET\":\n        events = Event.objects.all()\n        events_with_forms = []\n        for event in events:\n            events_with_forms.append({\n                'event': event,\n                'form': EventEditForm(instance=event),\n            })\n        return render(request, \"page.html\", {\n            'events_with_form': events_with_forms,\n            'new_event_form': EventEditForm(),\n        })\n    if request.method == \"POST\":\n        event_id = request.POST.get('event_id')\n        if not event_id:\n            form = EventEditForm(request.POST, request.FILES)\n            if form.is_valid():\n                form.save()\n                return redirect('home')\n\n        event = get_object_or_404(Event, pk=event_id)\n        form = EventEditForm(request.POST, request.FILES, instance=event)\n        if form.is_valid():\n            form.save()\n            return redirect('home')\n</code></pre> <pre><code>&lt;!-- templates/page.html --&gt;\n{% load crispy_forms_filters %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    {{new_event_form.media}}\n&lt;/head&gt;\n&lt;body&gt;\n\n    {% for event in events_with_form %}\n        &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n            {% csrf_token %}\n            &lt;input type=\"hidden\" name=\"event_id\" value=\"{{ event.event.id }}\"&gt;\n            {{ event.form|crispy }}\n            &lt;button type=\"submit\"&gt;Update&lt;/button&gt;\n        &lt;/form&gt;\n    {% endfor %}\n\n    &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n        {% csrf_token %}\n        {{ new_event_form|crispy }}\n        &lt;button type=\"submit\"&gt;Create&lt;/button&gt;\n    &lt;/form&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>By default, this does not work, and the reason for this is: the field id is used to control the <code>django-image-uploader-widget</code> and the field id is the same for each form. To solve this problem we have to change the field id attribute for each field, and this can be does changing the ModelForm:</p> <pre><code># forms.py\nfrom django import forms\nfrom image_uploader_widget.widgets import ImageUploaderWidget\nfrom .models import Event\n\nclass EventEditForm(forms.ModelForm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if self.instance:\n            id = str(self.instance.pk)\n            self.fields['headshot'].widget.attrs['id'] = \"headshot_%s\" % id\n\n    class Meta:\n        model = Event\n        widgets = {\n            'headshot': ImageUploaderWidget(),\n        }\n        fields = [\n            'event_title',\n            'headshot'\n        ]\n</code></pre> <p>The original answer is disponible, also, in the github issue.</p>"},{"location":"widget/resumed/","title":"Resumed","text":"<p>If you want to read a more complete description of how to use this widget, see the Tutorial. But, if you is an advanced user, only install the package:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>and add the <code>image_uploader_widget</code> to the <code>INSTALLED_APPS</code> in the <code>settings.py</code>:</p> <pre><code># ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n]\n\n# ...\n</code></pre> <p>And go to use it with your forms:</p> <pre><code>from django.forms import ModelForm\nfrom ecommerce.models import Product\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ProductForm(ModelForm):\n    class Meta:\n        model = Product\n        fields = ['name', 'image']\n        widgets = {\n            'image': ImageUploaderWidget()\n        }\n</code></pre> <p></p>"},{"location":"widget/tutorial/","title":"Tutorial","text":"<p>First, we need of some context: the image uploader widget is a widget to handle image uploading with a beautiful interface with click to select file and a drop file behaviour handler. It is used with django forms.</p> <p>This is a more long and for newbies tutorial of how to use this widget. If you is an advanced user, see the Resumed version.</p> <p>To write this tutorial of this documentation we go to create an empty django project, then if you don't want to see this part, skip to using the widget section. Another information is: we're assuming you already know the basics of django and already have it installed in your machine.</p>"},{"location":"widget/tutorial/#creating-a-django-project","title":"Creating a django project","text":"<p>First, create a project folder. Here we call it as <code>my-ecommerce</code>:</p> <pre><code>mkdir my-ecommerce\ncd my-ecommerce\n</code></pre> <p>And, now, create a django project in this folder:</p> <pre><code>django-admin startproject core .\n</code></pre> <p>And, then, we have the folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - manage.py\n</code></pre> <p>Create our django application by running the command:</p> <pre><code>python manage.py startapp ecommerce\n</code></pre> <p>And, now, we have a new, and more complex, folder structure:</p> <pre><code>| - my-ecommerce\n  | - core\n    | - asgi.py\n    | - __init__.py\n    | - settings.py\n    | - urls.py\n    | - wsgi.py\n  | - ecommerce\n    | - migrations\n      | - __init__.py\n    | - admin.py\n    | - apps.py\n    | - __init__.py\n    | - models.py\n    | - tests.py\n    | - views.py\n  | - manage.py\n</code></pre>"},{"location":"widget/tutorial/#installing-the-widget","title":"Installing the widget","text":"<p>To install the widget, is possible to use the same instructions of the Getting started, and the first step is to install the package with pip:</p> <pre><code>pip install django-image-uploader-widget\n</code></pre> <p>then, add it to the <code>INSTALLED_APPS</code> on the <code>settings.py</code>, in the case of this example: <code>core/settings.py</code> file. To understand better the Applications, see the django documentation: Applications.</p> <pre><code># core/settings.py\n# ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n]\n\n# ...\n</code></pre>"},{"location":"widget/tutorial/#warning","title":"Warning","text":"<p>Observation: note that the application name to be added on the <code>INSTALLED_APPS</code> are not equals to the pip package name / install name.</p>"},{"location":"widget/tutorial/#using-the-widget","title":"Using the widget","text":"<p>We have two basic modes to use this widget:</p> <ol> <li> <p>creating a ORM <code>Model</code> and using an <code>ModelForm</code> to it setting the widget.</p> </li> <li> <p>creating an custom <code>Form</code> with any other behaviour.</p> </li> </ol>"},{"location":"widget/tutorial/#with-modelform","title":"With ModelForm","text":"<p>First, go to our ecommerce app models <code>ecommerce/models.py</code> and create a basic django model with an <code>ImageField</code>:</p> <pre><code># ecommerce/models.py\nfrom django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    image = models.ImageField()\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        verbose_name = 'Product'\n        verbose_name_plural = 'Products'\n</code></pre> <p>Now, we go to create our <code>ModelForm</code>. Create a empty file on <code>ecommerce/forms.py</code> to store our django forms. And create our own <code>ProductForm</code>:</p> <pre><code># ecommerce/forms.py\nfrom django.forms import ModelForm\nfrom ecommerce.models import Product\n\nclass ProductForm(ModelForm):\n    class Meta:\n        model = Product\n        fields = ['name', 'image']\n</code></pre> <p>And, here, we can declare the widget that our <code>image</code> field uses:</p> <pre><code># ecommerce/forms.py\nfrom django.forms import ModelForm\nfrom ecommerce.models import Product\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ProductForm(ModelForm):\n    class Meta:\n        model = Product\n        fields = ['name', 'image']\n        widgets = {\n            'image': ImageUploaderWidget()\n        }\n</code></pre>"},{"location":"widget/tutorial/#creating-and-applying-migrations","title":"Creating and applying migrations","text":"<p>Our Model, declared in the above section, needs to be inserted on our database using the migrations. To create our migrations, we need to add our <code>ecommerce</code> app to <code>INSTALLED_APPS</code> on the <code>settings.py</code>:</p> <pre><code># core/settings.py\n# ...\n\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'image_uploader_widget',\n    'ecommerce',\n]\n\n# ...\n</code></pre> <p>Now, we go to create the migrations using the command:</p> <pre><code>python manage.py makemigrations\n</code></pre> <p>If you found an <code>ecommerce.Product.image: (fields.E210) Cannot use ImageField because Pillow is not installed.</code> error, just run an:</p> <pre><code>pip install Pillow\n</code></pre> <p>and re-run the makemigrations command. Now, we go to apply the migrations with:</p> <pre><code>python manage.py migrate\n</code></pre> <p>And, now, we can run the development server to see our next steps coding:</p> <pre><code>python manage.py runserver\n</code></pre>"},{"location":"widget/tutorial/#see-it-in-the-action","title":"See it in the action","text":"<p>To see the widget in action, just go to the ecommerce app and create, in the <code>views.py</code>, an view that renders an form:</p> <pre><code># ecommerce/views.py\nfrom django.shortcuts import render\nfrom ecommerce.forms import ProductForm\n\ndef test_widget(request):\n    context = { 'form': ProductForm() }\n    return render(request, 'test_widget.html', context)\n</code></pre> <p>Now, we can create an <code>templates</code> folder in the <code>ecommerce</code> application and inside it we need to create a <code>test_widget.html</code>:</p> <pre><code>&lt;!-- ecommerce/templates/test_widget.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    {{ form.media }}\n&lt;/head&gt;\n&lt;body&gt;\n\n    {{ form.as_p }}\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>And register this view in the <code>core/urls.py</code>:</p> <pre><code># core/urls.py\nfrom django.contrib import admin\nfrom django.urls import path\nfrom ecommerce.views import test_widget\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('test_widget/', test_widget),\n]\n</code></pre> <p>And go to the browser in <code>http://localhost:8000/test_widget/</code> and see the result:</p> <p></p>"},{"location":"widget/tutorial/#with-form-and-custom-behaviour","title":"With Form and custom behaviour","text":"<p>It's very like the above item and we need only to change some things in the <code>forms.py</code>:</p> <pre><code>from django import forms\nfrom ecommerce.models import Product\nfrom image_uploader_widget.widgets import ImageUploaderWidget\n\nclass ProductForm(forms.Form):\n    image = forms.ImageField(widget=ImageUploaderWidget())\n\n    class Meta:\n        fields = ['image']\n</code></pre> <p>And we not need to change nothing more. It works.</p>"},{"location":"widget/tutorial/#comments-about-using-with-django-admin","title":"Comments about using with django-admin","text":"<p>The use with django-admin is very like it: we only needs to create <code>ModelForm</code> for our models and in the <code>ModelAdmin</code> (django documentation) we set our form (here is an example).</p>"}]}